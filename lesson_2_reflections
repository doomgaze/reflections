Question:
What happens when you initialize a repository? Why do you need to do it?

Answer:
When you initialize a repository with 'git init' - git creates a .git file which is hidden
from the average user. This file is needed because it contains a bunch of metadata about the 
history of the repository (commits, changes, etc) since it was created.

Question:
How is the staging area different from the working directory and the repository? What value do
you think it offers?

Answer:
The staging area is different from both the working directory and the repository by being the
intermediary for them both. It allows for you to add commits to a pool 
'working directory --> staging area' and if you're satisfied with your work, you can commit it 
from the 'staging area --> repository'.

The value it offers, the way I understand and see it right now is that it's almost like an area
where you are commited to pushing these changes but haven't fully commited yet.

Question:
How can you use the staging area to make sure you have one commit per logical change?

		-------------------------------------------------
		| Working Directory | Staging Area | Repository |
		------------------------------------------------- 

Answer:
You can use the staging area to make sure you have one commit per logical change by comparing
the working directory to the staging area by 'git diff'. 

This compares changes you've made locally and the files which are in the staging area (will be 
the latest commit in repository, if you didn't add anything to staging at this point).

You can than 'git add <filename>' to add the file to git's staging area. From here -- you can run
'git diff --staged' to compare the item(s) in the staging area to the latest commit in the 
repository.

If you're satisfied with the changes - 'git commit', add an appropriate comment and save. Keep adding
and commiting until have all what you want commited. If there's anything you DONT want to commit --
doing a 'git reset --hard' will discard any changes in either the working directory or staging area.

Question:
What are some situations when brances would be helpful in keeping your history orangized? how would
branches help?

//some commands
- 'git branch' to see all the branches
- 'git branch <name>' to create a new branch
- 'git checkout <branch name>' to change branches

Answer:
Some situations when brances would be helpful in keeping your history organized would be;
	- Making an experimental feature
	- Create a dev test branch (making it easier, various commands maybe)
	- Major patch increments (v9, v10, v11 versus minor e.g. 9.32.v2, 9.32.v5 rev2)
	- Different languages e.g. Italian, Russian, German, etc.

Branches helps when you switch to work on a new feature or bug, when a big change is introduced and
you want to maybe merge it later on into the MASTER production quality branch that never breaks, always
works.

You could have an active development branch, where active development is taking place on your project.
Experimental branch, where you expect stuff to break - but you want to share it with the public or whatever.

